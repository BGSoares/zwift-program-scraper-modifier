# Product Specification: Zwift Workout Modifier

## 1. Overview

### 1.1 Purpose
Modify existing Zwift workout files (.zwo format) from the Active Offseason training program to fit a realistic weekly training schedule by reducing workout durations while preserving training quality.

### 1.2 Target User
Amateur cyclist with limited weekday training time (60-75 min max) who needs to compress a structured training program without losing key interval work.

### 1.3 Success Criteria
- Correctly identify and categorize workout types from .zwo files
- Preserve all high-intensity interval training exactly as written
- Reduce weekday workout durations to â‰¤75 minutes
- Maintain weekend endurance rides unchanged
- Skip active recovery workouts in high-volume weeks
- Output valid .zwo files that Zwift can import
- Generate comprehensive modification report

---

## 2. Technical Background

### 2.1 Input Format

**Input:** Directory containing .zwo files generated by Zwift Workout Scraper

**File naming convention (from scraper):**
```
Week1_Day1_Endurance.zwo
Week1_Day3_Cadence_Tempo.zwo
Week2_Day1_Endurance.zwo
...
Week12_Day6_Endurance.zwo
```

**Alternative naming patterns to support:**
- `Week_1_Day_1_Endurance.zwo`
- `w1_d1_endurance.zwo`
- `Active Offseason - Week 1 Day 1.zwo`

### 2.2 .zwo File Structure

The program will read and modify XML files with this structure:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<workout_file>
    <author>WhatsOnZwift</author>
    <name>Active Offseason - Week 1 Day 1 - Endurance</name>
    <description>Endurance ride...</description>
    <sportType>bike</sportType>
    <tags>
        <tag name="ACTIVE OFFSEASON"/>
    </tags>
    <workout>
        <Warmup Duration="600" PowerLow="0.50" PowerHigh="0.75"/>
        <SteadyState Duration="7200" Power="0.73"/>
        <Cooldown Duration="600" PowerLow="0.60" PowerHigh="0.50"/>
    </workout>
</workout_file>
```

**XML segment types:**
- `<Warmup>` - gradual power increase
- `<Cooldown>` - gradual power decrease  
- `<SteadyState>` - constant power
- `<IntervalsT>` - structured intervals
- `<FreeRide>` - unstructured/rest

**Key attributes:**
- `Duration` - in seconds (integer)
- `Power` - decimal (e.g., 0.73 = 73% FTP)
- `PowerLow` / `PowerHigh` - for ramps
- `Repeat`, `OnDuration`, `OffDuration`, `OnPower`, `OffPower` - for intervals

### 2.3 Power Zones (% FTP)

```python
ZONE_1_MAX = 55    # Active Recovery
ZONE_2_MAX = 75    # Endurance
ZONE_3_MAX = 90    # Tempo
ZONE_4_MAX = 105   # Threshold
ZONE_5_MAX = 120   # VO2 Max
ZONE_6_MIN = 120   # Anaerobic/Sprint
```

---

## 3. Functional Requirements

### 3.1 Input Handling

**FR-1.1: Directory Scanning**
```python
- Accept input directory path containing .zwo files
- Recursively scan for all .zwo files
- Parse XML structure of each file
- Handle malformed/invalid XML gracefully with error logging
- Sort files by week and day number
```

**FR-1.2: Workout Metadata Extraction**

From filename:
```python
filename = "Week3_Day2_Endurance.zwo"
extract:
  week_number = 3
  day_number = 2
  workout_type_hint = "Endurance"
```

From XML content:
```python
extract:
  name = <name> tag content
  description = <description> tag content
  total_duration = sum of all segment durations
  segments = list of all workout segments with type, duration, power
```

**FR-1.3: Week Grouping**
```python
# Group workouts by week number
weeks = {
    1: [workout1, workout2, workout3, workout4],
    2: [workout1, workout2, workout3, workout4, workout5],
    ...
    12: [workout1, workout2, workout3, workout4]
}

# Sort workouts within each week by day number
for week in weeks:
    weeks[week].sort(by=day_number)
```

### 3.2 Workout Classification

**FR-2.1: Primary Classification (Filename Analysis)**

Extract workout type from filename:

```python
FILENAME_KEYWORDS = {
    'recovery': ['rest', 'recovery', 'easy'],
    'endurance': ['endurance', 'base', 'long', 'steady'],
    'interval': ['interval', 'vo2', 'threshold', 'sweet', 'spot', 'tempo', 'cadence', 'over', 'under'],
    'mixed': []  # default if no clear match
}

def classify_from_filename(filename: str) -> str:
    filename_lower = filename.lower()
    for workout_type, keywords in FILENAME_KEYWORDS.items():
        if any(keyword in filename_lower for keyword in keywords):
            return workout_type
    return 'mixed'
```

**FR-2.2: Secondary Classification (Segment Analysis)**

If filename classification is ambiguous, analyze workout structure:

```python
def classify_from_segments(segments: List[Segment]) -> str:
    total_duration = sum(seg.duration for seg in segments)
    high_intensity_duration = sum(
        seg.duration for seg in segments 
        if seg.power and seg.power >= 0.90  # Z4+
    )
    
    intensity_ratio = high_intensity_duration / total_duration
    avg_power = calculate_average_power(segments)
    
    # Classification logic
    if intensity_ratio > 0.3:
        return 'interval'
    elif total_duration > 5400 and avg_power < 0.75:  # >90min and <75% FTP
        return 'endurance'
    elif total_duration < 3600 and avg_power < 0.65:  # <60min and <65% FTP
        return 'recovery'
    else:
        return 'mixed'
```

**FR-2.3: Workout Difficulty Scoring**

Calculate difficulty for identifying "lightest" workout to skip:

```python
def calculate_difficulty_score(workout: Workout) -> float:
    """
    Lower score = lighter workout
    """
    total_duration_minutes = workout.total_duration / 60
    avg_power = calculate_average_power(workout.segments)
    
    # Weighted average considering intensity distribution
    intensity_factor = 0
    for segment in workout.segments:
        if segment.power:
            intensity_factor += (segment.power * segment.duration)
    
    intensity_factor /= workout.total_duration
    
    # Difficulty score
    difficulty = (intensity_factor * total_duration_minutes) / 100
    
    return difficulty
```

### 3.3 Workout Selection Rules

**FR-3.1: Skip Logic for High-Volume Weeks**

```python
def identify_workouts_to_skip(week_workouts: List[Workout]) -> List[Workout]:
    """
    Skip workouts if week has â‰¥5 workouts
    """
    if len(week_workouts) < 5:
        return []  # Don't skip anything
    
    # First, try to identify active recovery workouts
    recovery_workouts = [
        w for w in week_workouts 
        if w.classification == 'recovery'
    ]
    
    if recovery_workouts:
        # Skip the lightest recovery workout
        recovery_workouts.sort(key=lambda w: w.difficulty_score)
        return [recovery_workouts[0]]
    
    # If no recovery workouts, skip the lightest workout overall
    week_workouts_sorted = sorted(week_workouts, key=lambda w: w.difficulty_score)
    return [week_workouts_sorted[0]]
```

**FR-3.2: Weekend Ride Identification**

```python
def identify_weekend_ride(week_workouts: List[Workout]) -> Workout:
    """
    Identify the weekend long ride (last workout of week, typically longest)
    """
    # Assumption: workouts are sorted by day number
    # Weekend ride is the last workout in the week
    
    # Additional validation: should be longest or second-longest ride
    week_workouts_sorted = sorted(week_workouts, key=lambda w: w.day_number)
    last_workout = week_workouts_sorted[-1]
    
    # Verify it's a reasonably long ride (>90 min)
    if last_workout.total_duration >= 5400:  # 90 minutes
        return last_workout
    
    # Fallback: find longest workout in week
    longest_workout = max(week_workouts, key=lambda w: w.total_duration)
    return longest_workout
```

**FR-3.3: Weekday Ride Processing Logic**

```python
def determine_modification_action(workout: Workout, 
                                   weekend_ride: Workout,
                                   skipped_workouts: List[Workout],
                                   target_duration: int = 4500) -> str:
    """
    Determine what action to take for each workout
    
    Returns: 'skip' | 'keep_unchanged' | 'shorten'
    """
    # Skip if marked for skipping
    if workout in skipped_workouts:
        return 'skip'
    
    # Keep weekend ride unchanged
    if workout == weekend_ride:
        return 'keep_unchanged'
    
    # Keep if already at or under target duration (75 min = 4500 sec)
    if workout.total_duration <= target_duration:
        return 'keep_unchanged'
    
    # Otherwise, shorten
    return 'shorten'
```

### 3.4 Workout Modification Rules

**FR-4.1: Segment Type Identification**

Classify each segment in a workout:

```python
def classify_segment(segment: WorkoutSegment) -> str:
    """
    Classify segment as: warmup, cooldown, endurance, interval, recovery
    """
    # Based on XML element type
    if segment.xml_type == 'Warmup':
        return 'warmup'
    if segment.xml_type == 'Cooldown':
        return 'cooldown'
    if segment.xml_type == 'IntervalsT':
        return 'interval'
    if segment.xml_type == 'FreeRide':
        return 'recovery'
    
    # For SteadyState, classify by power
    if segment.xml_type == 'SteadyState':
        power = segment.power
        if power < 0.55:
            return 'recovery'
        elif power < 0.90:
            return 'endurance'  # Z2-Z3
        else:
            return 'interval'  # Z4+
    
    return 'unknown'
```

**FR-4.2: Identify Cuttable vs. Preserve Segments**

```python
def identify_cuttable_segments(workout: Workout) -> Tuple[List, List]:
    """
    Returns: (cuttable_segments, preserve_segments)
    """
    cuttable = []
    preserve = []
    
    for segment in workout.segments:
        seg_type = classify_segment(segment)
        
        # PRESERVE: All intervals (Z4+)
        if seg_type == 'interval':
            preserve.append(segment)
        
        # PRESERVE: IntervalsT elements (structured intervals)
        elif segment.xml_type == 'IntervalsT':
            preserve.append(segment)
        
        # CUTTABLE: Endurance segments (Z2-Z3)
        elif seg_type == 'endurance':
            cuttable.append(segment)
        
        # CUTTABLE: Warmup (but enforce minimum)
        elif seg_type == 'warmup':
            cuttable.append(segment)
        
        # CUTTABLE: Cooldown (but enforce minimum)
        elif seg_type == 'cooldown':
            cuttable.append(segment)
        
        # PRESERVE by default: recovery, unknown
        else:
            preserve.append(segment)
    
    return cuttable, preserve
```

**FR-4.3: Duration Calculation**

```python
def calculate_cut_requirements(workout: Workout, 
                               target_duration: int = 4500) -> Dict:
    """
    Calculate how much time needs to be cut
    
    Returns:
        {
            'current_duration': int,
            'target_duration': int,
            'time_to_cut': int,
            'cuttable_duration': int,
            'is_feasible': bool
        }
    """
    current_duration = workout.total_duration
    time_to_cut = current_duration - target_duration
    
    cuttable_segments, preserve_segments = identify_cuttable_segments(workout)
    cuttable_duration = sum(seg.duration for seg in cuttable_segments)
    
    # Check if cut is feasible
    # Need to keep minimum warmup (300s) and cooldown (300s)
    warmup_segments = [s for s in cuttable_segments if classify_segment(s) == 'warmup']
    cooldown_segments = [s for s in cuttable_segments if classify_segment(s) == 'cooldown']
    
    min_warmup = min(300, sum(s.duration for s in warmup_segments))
    min_cooldown = min(300, sum(s.duration for s in cooldown_segments))
    
    max_cuttable = cuttable_duration - min_warmup - min_cooldown
    
    return {
        'current_duration': current_duration,
        'target_duration': target_duration,
        'time_to_cut': time_to_cut,
        'cuttable_duration': cuttable_duration,
        'max_cuttable': max_cuttable,
        'is_feasible': time_to_cut <= max_cuttable
    }
```

**FR-4.4: Proportional Cutting Algorithm**

```python
def apply_proportional_cuts(workout: Workout, 
                           target_duration: int = 4500) -> Workout:
    """
    Apply proportional cuts to endurance segments
    Keep warmup/cooldown minimums
    Preserve all intervals
    """
    cut_info = calculate_cut_requirements(workout, target_duration)
    
    if not cut_info['is_feasible']:
        logging.warning(
            f"Cannot cut {workout.name} to {target_duration}s. "
            f"Cutting as much as possible."
        )
    
    time_to_cut = cut_info['time_to_cut']
    cuttable_segments, preserve_segments = identify_cuttable_segments(workout)
    
    # Separate warmup/cooldown from endurance segments
    warmup_segments = [s for s in cuttable_segments if classify_segment(s) == 'warmup']
    cooldown_segments = [s for s in cuttable_segments if classify_segment(s) == 'cooldown']
    endurance_segments = [s for s in cuttable_segments if classify_segment(s) == 'endurance']
    
    # Calculate current totals
    warmup_duration = sum(s.duration for s in warmup_segments)
    cooldown_duration = sum(s.duration for s in cooldown_segments)
    endurance_duration = sum(s.duration for s in endurance_segments)
    
    # Define minimums
    MIN_WARMUP = 300  # 5 minutes
    MIN_COOLDOWN = 300  # 5 minutes
    
    # Step 1: Cut from endurance segments first (proportionally)
    endurance_cut = min(time_to_cut, endurance_duration)
    remaining_cut = time_to_cut - endurance_cut
    
    if endurance_duration > 0:
        cut_ratio = endurance_cut / endurance_duration
        for segment in endurance_segments:
            reduction = int(segment.duration * cut_ratio)
            segment.duration -= reduction
            
            # Remove segment if too short
            if segment.duration < 60:  # Less than 1 minute
                segment.duration = 0
    
    # Step 2: Cut from warmup if needed (maintain minimum)
    if remaining_cut > 0 and warmup_duration > MIN_WARMUP:
        warmup_cut = min(remaining_cut, warmup_duration - MIN_WARMUP)
        cut_ratio = warmup_cut / warmup_duration
        
        for segment in warmup_segments:
            reduction = int(segment.duration * cut_ratio)
            new_duration = segment.duration - reduction
            segment.duration = max(MIN_WARMUP, new_duration)
        
        remaining_cut -= warmup_cut
    
    # Step 3: Cut from cooldown if still needed (maintain minimum)
    if remaining_cut > 0 and cooldown_duration > MIN_COOLDOWN:
        cooldown_cut = min(remaining_cut, cooldown_duration - MIN_COOLDOWN)
        cut_ratio = cooldown_cut / cooldown_duration
        
        for segment in cooldown_segments:
            reduction = int(segment.duration * cut_ratio)
            new_duration = segment.duration - reduction
            segment.duration = max(MIN_COOLDOWN, new_duration)
        
        remaining_cut -= cooldown_cut
    
    # Remove zero-duration segments
    workout.segments = [s for s in workout.segments if s.duration > 0]
    
    # Recalculate total duration
    workout.total_duration = sum(s.duration for s in workout.segments)
    
    # Log if target not achieved
    if remaining_cut > 0:
        logging.warning(
            f"{workout.name}: Could not reach target. "
            f"Final duration: {workout.total_duration}s (target: {target_duration}s)"
        )
    
    return workout
```

**FR-4.5: Interval Preservation Validation**

```python
def validate_interval_preservation(original: Workout, 
                                   modified: Workout) -> bool:
    """
    Verify that all interval segments remain unchanged
    """
    original_intervals = [
        s for s in original.segments 
        if classify_segment(s) == 'interval' or s.xml_type == 'IntervalsT'
    ]
    
    modified_intervals = [
        s for s in modified.segments 
        if classify_segment(s) == 'interval' or s.xml_type == 'IntervalsT'
    ]
    
    if len(original_intervals) != len(modified_intervals):
        logging.error(f"Interval count mismatch in {modified.name}")
        return False
    
    for orig, mod in zip(original_intervals, modified_intervals):
        if orig.duration != mod.duration:
            logging.error(
                f"Interval duration changed in {modified.name}: "
                f"{orig.duration}s -> {mod.duration}s"
            )
            return False
        
        if orig.power != mod.power:
            logging.error(
                f"Interval power changed in {modified.name}: "
                f"{orig.power} -> {mod.power}"
            )
            return False
    
    return True
```

### 3.5 Output Generation

**FR-5.1: File Naming Convention**

```python
def generate_output_filename(workout: Workout, 
                            original_filename: str) -> str:
    """
    Generate output filename
    
    Options:
    1. Append '_MODIFIED' suffix: Week1_Day1_Endurance_MODIFIED.zwo
    2. Keep original name in separate directory
    3. Add metadata in filename: Week1_Day1_Endurance_75min.zwo
    """
    # Default: append _MODIFIED suffix
    base_name = original_filename.replace('.zwo', '')
    return f"{base_name}_MODIFIED.zwo"
```

**FR-5.2: XML Output**

```python
def generate_modified_xml(workout: Workout) -> ET.Element:
    """
    Generate XML from modified workout
    Preserve original structure, update segment durations
    """
    root = ET.Element('workout_file')
    
    # Copy metadata from original
    author = ET.SubElement(root, 'author')
    author.text = workout.author
    
    name = ET.SubElement(root, 'name')
    name.text = workout.name
    
    # Add modification note to description
    description = ET.SubElement(root, 'description')
    original_desc = workout.description or ""
    modification_note = (
        f"\n[MODIFIED: Duration reduced from "
        f"{workout.original_duration // 60}min to "
        f"{workout.total_duration // 60}min. "
        f"Interval work preserved.]"
    )
    description.text = original_desc + modification_note
    
    sport_type = ET.SubElement(root, 'sportType')
    sport_type.text = 'bike'
    
    # Copy tags
    if workout.tags:
        tags = ET.SubElement(root, 'tags')
        for tag_name in workout.tags:
            tag = ET.SubElement(tags, 'tag')
            tag.set('name', tag_name)
    
    # Add workout segments with updated durations
    workout_elem = ET.SubElement(root, 'workout')
    
    for segment in workout.segments:
        if segment.duration == 0:
            continue  # Skip zero-duration segments
        
        seg_elem = create_segment_element(segment)
        workout_elem.append(seg_elem)
    
    return root

def create_segment_element(segment: WorkoutSegment) -> ET.Element:
    """
    Create XML element for a segment with proper attributes
    """
    elem = ET.Element(segment.xml_type)
    elem.set('Duration', str(segment.duration))
    
    if segment.xml_type in ['Warmup', 'Cooldown']:
        elem.set('PowerLow', f"{segment.power_low:.2f}")
        elem.set('PowerHigh', f"{segment.power_high:.2f}")
    
    elif segment.xml_type == 'SteadyState':
        elem.set('Power', f"{segment.power:.2f}")
        if segment.cadence:
            elem.set('Cadence', str(segment.cadence))
    
    elif segment.xml_type == 'IntervalsT':
        elem.set('Repeat', str(segment.repeat))
        elem.set('OnDuration', str(segment.on_duration))
        elem.set('OffDuration', str(segment.off_duration))
        elem.set('OnPower', f"{segment.on_power:.2f}")
        elem.set('OffPower', f"{segment.off_power:.2f}")
        if segment.cadence:
            elem.set('Cadence', str(segment.cadence))
    
    elif segment.xml_type == 'FreeRide':
        elem.set('FlatRoad', '1')
    
    # Add pace attribute (usually 0)
    elem.set('pace', '0')
    
    return elem
```

**FR-5.3: XML Formatting and Writing**

```python
def write_zwo_file(workout: Workout, output_path: Path) -> None:
    """
    Write modified workout to .zwo file with proper formatting
    """
    root = generate_modified_xml(workout)
    
    # Pretty print XML
    xml_string = minidom.parseString(
        ET.tostring(root, encoding='utf-8')
    ).toprettyxml(indent="    ")
    
    # Remove extra blank lines
    xml_string = '\n'.join([
        line for line in xml_string.split('\n') 
        if line.strip()
    ])
    
    # Write to file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(xml_string)
    
    logging.info(f"Wrote: {output_path}")
```

**FR-5.4: Modification Summary Log**

Generate detailed modification report:

```python
def generate_modification_report(all_workouts: List[Workout],
                                modifications: Dict) -> str:
    """
    Generate markdown report of all modifications
    """
    report_lines = [
        "# Zwift Workout Modification Report",
        "",
        f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        "",
        "## Summary",
        "",
        f"- Total workouts processed: {len(all_workouts)}",
        f"- Workouts modified: {modifications['modified_count']}",
        f"- Workouts skipped: {modifications['skipped_count']}",
        f"- Workouts unchanged: {modifications['unchanged_count']}",
        f"- Total time saved: {modifications['total_time_saved'] // 60} minutes",
        "",
        "## Week-by-Week Details",
        ""
    ]
    
    for week_num in sorted(modifications['by_week'].keys()):
        week_data = modifications['by_week'][week_num]
        report_lines.append(f"### Week {week_num}")
        report_lines.append("")
        
        for workout_mod in week_data['workouts']:
            status = workout_mod['status']
            name = workout_mod['name']
            
            if status == 'skipped':
                report_lines.append(f"- **{name}**: SKIPPED ({workout_mod['reason']})")
            elif status == 'unchanged':
                duration_min = workout_mod['duration'] // 60
                report_lines.append(
                    f"- **{name}**: Unchanged ({duration_min} min)"
                )
            elif status == 'modified':
                orig_min = workout_mod['original_duration'] // 60
                new_min = workout_mod['new_duration'] // 60
                cut_min = (workout_mod['original_duration'] - workout_mod['new_duration']) // 60
                report_lines.append(
                    f"- **{name}**: {orig_min} min â†’ {new_min} min "
                    f"(cut {cut_min} min from endurance)"
                )
        
        week_orig = week_data['original_duration'] // 60
        week_new = week_data['new_duration'] // 60
        report_lines.append("")
        report_lines.append(
            f"**Week {week_num} total**: "
            f"{week_orig // 60}h {week_orig % 60}m â†’ "
            f"{week_new // 60}h {week_new % 60}m"
        )
        report_lines.append("")
    
    return '\n'.join(report_lines)
```

---

## 4. Non-Functional Requirements

### 4.1 Performance
- Process 50-60 workout files in <5 seconds
- Memory efficient (process files sequentially)
- Validate all output before writing

### 4.2 Reliability
- Backup original files (optional flag)
- Validate all modified XML
- Verify interval preservation for every modified workout
- Detailed error logging with file names and line numbers

### 4.3 Usability
- Clear progress indicators
- Comprehensive modification report
- Dry-run mode to preview changes
- Verbose logging option

### 4.4 Maintainability
- Modular code structure
- Configurable parameters (target duration, minimums, zone definitions)
- Comprehensive unit tests
- Clear documentation

---

## 5. User Interface Specification

### 5.1 Command-Line Interface

```bash
python zwift_modifier.py [input_dir] [options]

Required:
  input_dir              Directory containing .zwo files to modify

Options:
  --output-dir DIR       Output directory (default: ./modified_workouts)
  --target-duration MIN  Target weekday duration in minutes (default: 75)
  --min-warmup MIN       Minimum warmup duration in minutes (default: 5)
  --min-cooldown MIN     Minimum cooldown duration in minutes (default: 5)
  --skip-threshold N     Skip workouts if week has >= N workouts (default: 5)
  --dry-run             Preview changes without writing files
  --backup              Create backup of original files
  --verbose             Detailed logging
  --report FILE         Output modification report (default: report.md)
  --no-interval-check   Skip interval preservation validation (not recommended)
```

### 5.2 Example Usage

```bash
# Basic usage
python zwift_modifier.py ./original_workouts \
    --output-dir ./modified_workouts

# Dry run to preview
python zwift_modifier.py ./original_workouts --dry-run

# Custom target duration with verbose logging
python zwift_modifier.py ./original_workouts \
    --target-duration 60 \
    --verbose \
    --backup

# Generate report to specific file
python zwift_modifier.py ./original_workouts \
    --output-dir ./modified_workouts \
    --report ./my_modifications.md
```

### 5.3 Output Messages

```
ðŸ” Scanning for .zwo files in ./original_workouts...
   Found 48 workout files

ðŸ“Š Grouping workouts by week...
   Week 1: 4 workouts
   Week 2: 5 workouts (1 will be skipped)
   Week 3: 4 workouts
   ...

âœ‚ï¸  Modifying workouts...
   
Week 1:
  âœ“ Day 1 - Endurance: 110 min â†’ 75 min (cut 35 min)
  âœ“ Day 2 - Rest: unchanged
  âœ“ Day 3 - Cadence & Tempo: 100 min â†’ 75 min (cut 25 min)
  âœ“ Day 5 - Endurance: 120 min â†’ unchanged (weekend ride)

Week 2:
  âœ“ Day 1 - Endurance: 120 min â†’ 75 min (cut 45 min)
  âŠ— Day 2 - Rest: SKIPPED (5+ workouts in week)
  âœ“ Day 3 - Tempo: 65 min â†’ unchanged
  ...

âœ… Complete! Modified 36 workouts, skipped 12
   ðŸ“ Output: ./modified_workouts/
   ðŸ“„ Report: ./report.md
   â±ï¸  Total time saved: 11.5 hours
   ðŸŽ¯ New weekly average: 5.8 hours
```

---

## 6. Testing Requirements

### 6.1 Unit Tests

**Test Coverage:**
- XML parsing (valid files, malformed files)
- Workout classification (all types)
- Difficulty scoring
- Skip logic (various week sizes)
- Weekend ride identification
- Segment classification
- Proportional cutting algorithm
- Warmup/cooldown minimum enforcement
- Interval preservation
- XML generation
- Filename handling (various formats)

**Test Data:**
Create sample .zwo files:
- Pure endurance ride (2 hours, all Z2)
- Interval workout (60 min with 5x5min Z5 intervals)
- Mixed workout (90 min with Z2 + Z3 tempo)
- Short recovery (45 min, Z1-Z2)
- Complex intervals (IntervalsT elements)
- Workout with long warmup/cooldown

### 6.2 Integration Tests

- Process sample week (7 files) and verify output
- Process full program (12 weeks) and verify:
  - Correct skip logic
  - Weekend rides unchanged
  - Weekday rides modified correctly
  - Intervals preserved
- Verify all output files are valid XML
- Verify report generation

### 6.3 Validation Tests

**Critical validation:**
- [ ] All intervals preserved (duration and power)
- [ ] Weekend rides unchanged
- [ ] Weekday rides â‰¤75 minutes (or as close as possible)
- [ ] All output files valid XML
- [ ] All output files importable to Zwift
- [ ] No negative durations
- [ ] Warmup/cooldown minimums enforced
- [ ] Total weekly time reduced appropriately

### 6.4 End-to-End Tests

**Manual testing checklist:**
- [ ] Process full Active Offseason program
- [ ] Import modified .zwo files into Zwift
- [ ] Verify workouts display correctly
- [ ] Spot-check 10 workouts for accuracy:
  - [ ] Intervals intact
  - [ ] Endurance sections reduced
  - [ ] Warmup/cooldown reasonable
- [ ] Verify modification report accuracy
- [ ] Test dry-run mode
- [ ] Test backup functionality

---

## 7. Error Handling

### 7.1 File-Level Errors

| Error Type | Handling Strategy |
|-----------|------------------|
| File not found | Log error, skip file, continue |
| Invalid XML | Log error with line number, skip file |
| Missing required elements | Log warning, attempt to infer, skip if critical |
| Corrupted .zwo file | Log error, skip file |
| Unreadable file | Log error with permissions info, skip file |

### 7.2 Processing Errors

| Error Type | Handling Strategy |
|-----------|------------------|
| Cannot classify workout | Use 'mixed' classification, log warning |
| Cannot identify weekend ride | Use longest workout, log warning |
| Insufficient segments to cut | Cut as much as possible, log warning |
| Interval modification detected | ERROR - reject modified workout |
| Zero-duration workout after cuts | Log error, don't output file |

### 7.3 Output Errors

| Error Type | Handling Strategy |
|-----------|------------------|
| Output directory not writable | Exit with clear error message |
| Cannot write file | Log error, continue with other files |
| Invalid XML generated | Don't write file, log error with details |
| Filename collision | Append number suffix, log warning |

---

## 8. Configuration

### 8.1 Constants

```python
# Target durations
TARGET_WEEKDAY_DURATION = 75 * 60  # 75 minutes in seconds
MIN_WARMUP_DURATION = 5 * 60  # 5 minutes
MIN_COOLDOWN_DURATION = 5 * 60  # 5 minutes

# Skip threshold
SKIP_THRESHOLD_WORKOUTS = 5  # Skip recovery if week has â‰¥5 workouts

# Power zones (% FTP)
ZONE_1_MAX = 0.55  # 55% FTP
ZONE_2_MAX = 0.75  # 75% FTP
ZONE_3_MAX = 0.90  # 90% FTP
ZONE_4_MAX = 1.05  # 105% FTP
ZONE_5_MAX = 1.20  # 120% FTP

# Validation
MIN_SEGMENT_DURATION = 60  # 1 minute in seconds
MIN_WORKOUT_DURATION = 300  # 5 minutes
MAX_WORKOUT_DURATION = 14400  # 4 hours

# Filename patterns
WEEK_PATTERNS = [
    r'[Ww]eek[_ ]?(\d+)',
    r'[Ww](\d+)',
]
DAY_PATTERNS = [
    r'[Dd]ay[_ ]?(\d+)',
    r'[Dd](\d+)',
]
```

### 8.2 Logging Configuration

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('zwift_modifier.log'),
        logging.StreamHandler()
    ]
)
```

---

## 9. Code Structure

### 9.1 Suggested File Organization

```
zwift_modifier/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ main.py              # CLI entry point
â”œâ”€â”€ parser.py            # .zwo XML parsing
â”œâ”€â”€ classifier.py        # Workout classification
â”œâ”€â”€ modifier.py          # Workout modification logic
â”œâ”€â”€ selector.py          # Workout selection (skip/weekend logic)
â”œâ”€â”€ writer.py            # .zwo XML generation and file writing
â”œâ”€â”€ validator.py         # Validation logic
â”œâ”€â”€ reporter.py          # Report generation
â”œâ”€â”€ config.py            # Configuration constants
â”œâ”€â”€ models.py            # Data structures (Workout, Segment, etc.)
â””â”€â”€ utils.py             # Helper functions

tests/
â”œâ”€â”€ test_parser.py
â”œâ”€â”€ test_classifier.py
â”œâ”€â”€ test_modifier.py
â”œâ”€â”€ test_selector.py
â”œâ”€â”€ test_validator.py
â”œâ”€â”€ test_integration.py
â””â”€â”€ fixtures/            # Sample .zwo files
```

### 9.2 Key Data Structures

```python
from dataclasses import dataclass
from typing import List, Optional, Dict
import xml.etree.ElementTree as ET

@dataclass
class WorkoutSegment:
    """Single segment within a workout"""
    xml_type: str  # 'Warmup', 'Cooldown', 'SteadyState', 'IntervalsT', 'FreeRide'
    duration: int  # seconds
    
    # SteadyState attributes
    power: Optional[float] = None
    cadence: Optional[int] = None
    
    # Warmup/Cooldown attributes
    power_low: Optional[float] = None
    power_high: Optional[float] = None
    
    # IntervalsT attributes
    repeat: Optional[int] = None
    on_duration: Optional[int] = None
    off_duration: Optional[int] = None
    on_power: Optional[float] = None
    off_power: Optional[float] = None
    
    # Original XML element (for preservation)
    original_element: Optional[ET.Element] = None

@dataclass
class Workout:
    """Complete workout definition"""
    filename: str
    week_number: int
    day_number: int
    
    # XML content
    author: str
    name: str
    description: str
    sport_type: str
    tags: List[str]
    segments: List[WorkoutSegment]
    
    # Calculated properties
    total_duration: int  # seconds
    original_duration: int  # for modified workouts
    classification: str  # 'recovery', 'endurance', 'interval', 'mixed'
    difficulty_score: float
    
    # Processing flags
    is_weekend_ride: bool = False
    should_skip: bool = False
    modification_status: str = 'pending'  # 'pending', 'skipped', 'unchanged', 'modified'
    
    # Original XML tree (for preservation of unknown elements)
    original_xml: Optional[ET.Element] = None

@dataclass
class ModificationResult:
    """Result of modification for reporting"""
    workout_name: str
    week_number: int
    day_number: int
    status: str  # 'skipped', 'unchanged', 'modified'
    original_duration: int
    new_duration: int
    time_saved: int
    reason: Optional[str] = None  # For skipped workouts
    warning: Optional[str] = None
```

---

## 10. Acceptance Criteria

The implementation is complete when:

1. âœ… Program successfully processes all Active Offseason .zwo files
2. âœ… Correctly identifies and skips recovery rides in 5+ workout weeks
3. âœ… Weekend endurance rides remain completely unchanged
4. âœ… Weekday rides >75 min are reduced to â‰¤75 min
5. âœ… All interval segments preserved with exact original duration and power
6. âœ… Endurance segments cut proportionally
7. âœ… Warmup/cooldown minimums (5 min each) enforced
8. âœ… Output .zwo files are valid XML
9. âœ… Output .zwo files import successfully into Zwift
10. âœ… Comprehensive modification report generated
11. âœ… All unit and integration tests pass
12. âœ… Interval preservation validated for every modified workout
13. âœ… Weekly training time reduced from 8-10 hours to 5-6 hours

---

## 11. Future Enhancements (Out of Scope for V1)

- GUI interface
- Interactive mode (review each modification before applying)
- Custom modification rules per week
- TSS recalculation for modified workouts
- Alternative cutting strategies (e.g., preserve last endurance block)
- Support for other training programs
- Visualization of modifications
- Batch processing multiple programs
- Export summary to CSV/JSON
- Integration with Zwift API (if available)

---

## 12. Known Limitations

- **Assumes specific naming convention**: Relies on Week/Day in filename
- **Cannot handle custom .zwo files**: Only designed for Active Offseason structure
- **May produce unbalanced workouts**: If endurance segments are insufficient
- **No TSS recalculation**: Modified workouts will have outdated TSS values
- **No workout rebalancing**: Doesn't optimize workout structure, only cuts duration
- **Filename variations**: May not parse all possible filename formats

---

## 13. Appendix

### 13.1 Example Modification

**Original: Week 1 Day 1 - Endurance (110 minutes)**

```xml
<workout>
    <Warmup Duration="600" PowerLow="0.70" PowerHigh="0.75"/>
    <SteadyState Duration="5400" Power="0.73"/>
    <Cooldown Duration="600" PowerLow="0.75" PowerHigh="0.70"/>
</workout>
```

**Modified (75 minutes):**

```xml
<workout>
    <Warmup Duration="300" PowerLow="0.70" PowerHigh="0.75"/>
    <SteadyState Duration="3600" Power="0.73"/>
    <Cooldown Duration="600" PowerLow="0.75" PowerHigh="0.70"/>
</workout>
```

**Calculation:**
- Original: 600 + 5400 + 600 = 6600s (110 min)
- Target: 4500s (75 min)
- To cut: 2100s (35 min)
- Cuttable duration: 5400 + (600-300) + (600-300) = 6000s
- Cut from warmup: 300s (to minimum)
- Cut from endurance: 1800s (5400 * 0.333)
- Cut from cooldown: 0s (keep for recovery)
- Final: 300 + 3600 + 600 = 4500s âœ“

### 13.2 Complex Example

**Original: Week 1 Day 3 - Cadence & Tempo (100 minutes)**

Segments:
- 10min warmup: 50-55% FTP
- 2min @ 40% FTP
- 1min @ 88% FTP
- (repeated pattern 10 times)
- 15min @ 73% FTP
- 10min cooldown: 60-50% FTP

**Modification strategy:**
- PRESERVE: All 1min @ 88% FTP intervals (10 min total)
- PRESERVE: All 2min recovery between intervals (20 min total)
- CUT FROM: 15min endurance block â†’ ~5-8 min
- CUT FROM: Warmup 10min â†’ 5min
- KEEP: Cooldown 10min (already reasonable)

This keeps all high-intensity work while reducing total time to ~75 min.

### 13.3 Validation Checklist

Before outputting modified workout:

```python
validation_checks = {
    'xml_valid': True,  # Valid XML structure
    'has_name': True,  # Has <name> element
    'has_segments': True,  # Has <workout> with segments
    'positive_durations': True,  # All durations > 0
    'intervals_preserved': True,  # Intervals unchanged
    'warmup_minimum': True,  # Warmup >= 5 min (if present)
    'cooldown_minimum': True,  # Cooldown >= 5 min (if present)
    'reasonable_total': True,  # Total duration makes sense
}
```

---
